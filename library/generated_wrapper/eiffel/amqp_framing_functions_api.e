note

	description: "This file has been generated by WrapC. Do not edit. Changes will be lost!"

	generator: "Eiffel Wrapper Generator"
-- functions wrapper
class AMQP_FRAMING_FUNCTIONS_API


feature -- Access

	amqp_constant_name (constantnumber: INTEGER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_constant_name ((int)$constantnumber);
			]"
		end

	amqp_constant_is_hard_error (constantnumber: INTEGER): INTEGER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_constant_is_hard_error ((int)$constantnumber);
			]"
		end

	amqp_method_name (methodnumber: NATURAL): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_method_name ((amqp_method_number_t)$methodnumber);
			]"
		end

	amqp_method_has_content (methodnumber: NATURAL): INTEGER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_method_has_content ((amqp_method_number_t)$methodnumber);
			]"
		end

	amqp_decode_method (methodnumber: NATURAL; pool: AMQP_POOL_T__STRUCT_API; encoded: AMQP_BYTES_T__STRUCT_API; decoded: POINTER): INTEGER 
		do
			Result := c_amqp_decode_method (methodnumber, pool.item, encoded.item, decoded)
		ensure
			instance_free: class
		end

	amqp_decode_properties (class_id: NATURAL; pool: AMQP_POOL_T__STRUCT_API; encoded: AMQP_BYTES_T__STRUCT_API; decoded: POINTER): INTEGER 
		do
			Result := c_amqp_decode_properties (class_id, pool.item, encoded.item, decoded)
		ensure
			instance_free: class
		end

	amqp_encode_method (methodnumber: NATURAL; decoded: POINTER; encoded: AMQP_BYTES_T__STRUCT_API): INTEGER 
		do
			Result := c_amqp_encode_method (methodnumber, decoded, encoded.item)
		ensure
			instance_free: class
		end

	amqp_encode_properties (class_id: NATURAL; decoded: POINTER; encoded: AMQP_BYTES_T__STRUCT_API): INTEGER 
		do
			Result := c_amqp_encode_properties (class_id, decoded, encoded.item)
		ensure
			instance_free: class
		end

	amqp_channel_open (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL): detachable AMQP_CHANNEL_OPEN_OK_T__STRUCT_API 
		do
			if attached c_amqp_channel_open (state.item, channel) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_channel_flow (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; active: INTEGER): detachable AMQP_CHANNEL_FLOW_OK_T__STRUCT_API 
		do
			if attached c_amqp_channel_flow (state.item, channel, active) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_exchange_declare (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; exchange: AMQP_BYTES_T__STRUCT_API; type: AMQP_BYTES_T__STRUCT_API; passive: INTEGER; durable: INTEGER; auto_delete: INTEGER; internal: INTEGER; arguments: AMQP_TABLE_T__STRUCT_API): detachable AMQP_EXCHANGE_DECLARE_OK_T__STRUCT_API 
		do
			if attached c_amqp_exchange_declare (state.item, channel, exchange.item, type.item, passive, durable, auto_delete, internal, arguments.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_exchange_delete (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; exchange: AMQP_BYTES_T__STRUCT_API; if_unused: INTEGER): detachable AMQP_EXCHANGE_DELETE_OK_T__STRUCT_API 
		do
			if attached c_amqp_exchange_delete (state.item, channel, exchange.item, if_unused) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_exchange_bind (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; destination: AMQP_BYTES_T__STRUCT_API; source: AMQP_BYTES_T__STRUCT_API; routing_key: AMQP_BYTES_T__STRUCT_API; arguments: AMQP_TABLE_T__STRUCT_API): detachable AMQP_EXCHANGE_BIND_OK_T__STRUCT_API 
		do
			if attached c_amqp_exchange_bind (state.item, channel, destination.item, source.item, routing_key.item, arguments.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_exchange_unbind (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; destination: AMQP_BYTES_T__STRUCT_API; source: AMQP_BYTES_T__STRUCT_API; routing_key: AMQP_BYTES_T__STRUCT_API; arguments: AMQP_TABLE_T__STRUCT_API): detachable AMQP_EXCHANGE_UNBIND_OK_T__STRUCT_API 
		do
			if attached c_amqp_exchange_unbind (state.item, channel, destination.item, source.item, routing_key.item, arguments.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_queue_declare (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; queue: AMQP_BYTES_T__STRUCT_API; passive: INTEGER; durable: INTEGER; exclusive: INTEGER; auto_delete: INTEGER; arguments: AMQP_TABLE_T__STRUCT_API): detachable AMQP_QUEUE_DECLARE_OK_T__STRUCT_API 
		do
			if attached c_amqp_queue_declare (state.item, channel, queue.item, passive, durable, exclusive, auto_delete, arguments.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_queue_bind (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; queue: AMQP_BYTES_T__STRUCT_API; exchange: AMQP_BYTES_T__STRUCT_API; routing_key: AMQP_BYTES_T__STRUCT_API; arguments: AMQP_TABLE_T__STRUCT_API): detachable AMQP_QUEUE_BIND_OK_T__STRUCT_API 
		do
			if attached c_amqp_queue_bind (state.item, channel, queue.item, exchange.item, routing_key.item, arguments.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_queue_purge (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; queue: AMQP_BYTES_T__STRUCT_API): detachable AMQP_QUEUE_PURGE_OK_T__STRUCT_API 
		do
			if attached c_amqp_queue_purge (state.item, channel, queue.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_queue_delete (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; queue: AMQP_BYTES_T__STRUCT_API; if_unused: INTEGER; if_empty: INTEGER): detachable AMQP_QUEUE_DELETE_OK_T__STRUCT_API 
		do
			if attached c_amqp_queue_delete (state.item, channel, queue.item, if_unused, if_empty) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_queue_unbind (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; queue: AMQP_BYTES_T__STRUCT_API; exchange: AMQP_BYTES_T__STRUCT_API; routing_key: AMQP_BYTES_T__STRUCT_API; arguments: AMQP_TABLE_T__STRUCT_API): detachable AMQP_QUEUE_UNBIND_OK_T__STRUCT_API 
		do
			if attached c_amqp_queue_unbind (state.item, channel, queue.item, exchange.item, routing_key.item, arguments.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_basic_qos (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; prefetch_size: NATURAL; prefetch_count: NATURAL; global: INTEGER): detachable AMQP_BASIC_QOS_OK_T__STRUCT_API 
		do
			if attached c_amqp_basic_qos (state.item, channel, prefetch_size, prefetch_count, global) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_basic_consume (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; queue: AMQP_BYTES_T__STRUCT_API; consumer_tag: AMQP_BYTES_T__STRUCT_API; no_local: INTEGER; no_ack: INTEGER; exclusive: INTEGER; arguments: AMQP_TABLE_T__STRUCT_API): detachable AMQP_BASIC_CONSUME_OK_T__STRUCT_API 
		do
			if attached c_amqp_basic_consume (state.item, channel, queue.item, consumer_tag.item, no_local, no_ack, exclusive, arguments.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_basic_cancel (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; consumer_tag: AMQP_BYTES_T__STRUCT_API): detachable AMQP_BASIC_CANCEL_OK_T__STRUCT_API 
		do
			if attached c_amqp_basic_cancel (state.item, channel, consumer_tag.item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_basic_recover (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL; requeue: INTEGER): detachable AMQP_BASIC_RECOVER_OK_T__STRUCT_API 
		do
			if attached c_amqp_basic_recover (state.item, channel, requeue) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_tx_select (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL): detachable AMQP_TX_SELECT_OK_T__STRUCT_API 
		do
			if attached c_amqp_tx_select (state.item, channel) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_tx_commit (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL): detachable AMQP_TX_COMMIT_OK_T__STRUCT_API 
		do
			if attached c_amqp_tx_commit (state.item, channel) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_tx_rollback (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL): detachable AMQP_TX_ROLLBACK_OK_T__STRUCT_API 
		do
			if attached c_amqp_tx_rollback (state.item, channel) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

	amqp_confirm_select (state: AMQP_CONNECTION_STATE_T__STRUCT_API; channel: NATURAL): detachable AMQP_CONFIRM_SELECT_OK_T__STRUCT_API 
		do
			if attached c_amqp_confirm_select (state.item, channel) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer ( l_ptr )
			end

		ensure
			instance_free: class
		end

feature -- Externals

	c_amqp_decode_method (methodnumber: NATURAL; pool: POINTER; encoded: POINTER; decoded: POINTER): INTEGER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_decode_method ((amqp_method_number_t)$methodnumber, (amqp_pool_t*)$pool, *(amqp_bytes_t*)$encoded, (void**)$decoded);
			]"
		end

	c_amqp_decode_properties (class_id: NATURAL; pool: POINTER; encoded: POINTER; decoded: POINTER): INTEGER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_decode_properties ((uint16_t)$class_id, (amqp_pool_t*)$pool, *(amqp_bytes_t*)$encoded, (void**)$decoded);
			]"
		end

	c_amqp_encode_method (methodnumber: NATURAL; decoded: POINTER; encoded: POINTER): INTEGER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_encode_method ((amqp_method_number_t)$methodnumber, (void*)$decoded, *(amqp_bytes_t*)$encoded);
			]"
		end

	c_amqp_encode_properties (class_id: NATURAL; decoded: POINTER; encoded: POINTER): INTEGER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_encode_properties ((uint16_t)$class_id, (void*)$decoded, *(amqp_bytes_t*)$encoded);
			]"
		end

	c_amqp_channel_open (state: POINTER; channel: NATURAL): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_channel_open ((amqp_connection_state_t)$state, (amqp_channel_t)$channel);
			]"
		end

	c_amqp_channel_flow (state: POINTER; channel: NATURAL; active: INTEGER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_channel_flow ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, (amqp_boolean_t)$active);
			]"
		end

	c_amqp_exchange_declare (state: POINTER; channel: NATURAL; exchange: POINTER; type: POINTER; passive: INTEGER; durable: INTEGER; auto_delete: INTEGER; internal: INTEGER; arguments: POINTER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_exchange_declare ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, *(amqp_bytes_t*)$exchange, *(amqp_bytes_t*)$type, (amqp_boolean_t)$passive, (amqp_boolean_t)$durable, (amqp_boolean_t)$auto_delete, (amqp_boolean_t)$internal, *(amqp_table_t*)$arguments);
			]"
		end

	c_amqp_exchange_delete (state: POINTER; channel: NATURAL; exchange: POINTER; if_unused: INTEGER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_exchange_delete ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, *(amqp_bytes_t*)$exchange, (amqp_boolean_t)$if_unused);
			]"
		end

	c_amqp_exchange_bind (state: POINTER; channel: NATURAL; destination: POINTER; source: POINTER; routing_key: POINTER; arguments: POINTER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_exchange_bind ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, *(amqp_bytes_t*)$destination, *(amqp_bytes_t*)$source, *(amqp_bytes_t*)$routing_key, *(amqp_table_t*)$arguments);
			]"
		end

	c_amqp_exchange_unbind (state: POINTER; channel: NATURAL; destination: POINTER; source: POINTER; routing_key: POINTER; arguments: POINTER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_exchange_unbind ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, *(amqp_bytes_t*)$destination, *(amqp_bytes_t*)$source, *(amqp_bytes_t*)$routing_key, *(amqp_table_t*)$arguments);
			]"
		end

	c_amqp_queue_declare (state: POINTER; channel: NATURAL; queue: POINTER; passive: INTEGER; durable: INTEGER; exclusive: INTEGER; auto_delete: INTEGER; arguments: POINTER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_queue_declare ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, *(amqp_bytes_t*)$queue, (amqp_boolean_t)$passive, (amqp_boolean_t)$durable, (amqp_boolean_t)$exclusive, (amqp_boolean_t)$auto_delete, *(amqp_table_t*)$arguments);
			]"
		end

	c_amqp_queue_bind (state: POINTER; channel: NATURAL; queue: POINTER; exchange: POINTER; routing_key: POINTER; arguments: POINTER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_queue_bind ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, *(amqp_bytes_t*)$queue, *(amqp_bytes_t*)$exchange, *(amqp_bytes_t*)$routing_key, *(amqp_table_t*)$arguments);
			]"
		end

	c_amqp_queue_purge (state: POINTER; channel: NATURAL; queue: POINTER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_queue_purge ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, *(amqp_bytes_t*)$queue);
			]"
		end

	c_amqp_queue_delete (state: POINTER; channel: NATURAL; queue: POINTER; if_unused: INTEGER; if_empty: INTEGER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_queue_delete ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, *(amqp_bytes_t*)$queue, (amqp_boolean_t)$if_unused, (amqp_boolean_t)$if_empty);
			]"
		end

	c_amqp_queue_unbind (state: POINTER; channel: NATURAL; queue: POINTER; exchange: POINTER; routing_key: POINTER; arguments: POINTER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_queue_unbind ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, *(amqp_bytes_t*)$queue, *(amqp_bytes_t*)$exchange, *(amqp_bytes_t*)$routing_key, *(amqp_table_t*)$arguments);
			]"
		end

	c_amqp_basic_qos (state: POINTER; channel: NATURAL; prefetch_size: NATURAL; prefetch_count: NATURAL; global: INTEGER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_basic_qos ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, (uint32_t)$prefetch_size, (uint16_t)$prefetch_count, (amqp_boolean_t)$global);
			]"
		end

	c_amqp_basic_consume (state: POINTER; channel: NATURAL; queue: POINTER; consumer_tag: POINTER; no_local: INTEGER; no_ack: INTEGER; exclusive: INTEGER; arguments: POINTER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_basic_consume ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, *(amqp_bytes_t*)$queue, *(amqp_bytes_t*)$consumer_tag, (amqp_boolean_t)$no_local, (amqp_boolean_t)$no_ack, (amqp_boolean_t)$exclusive, *(amqp_table_t*)$arguments);
			]"
		end

	c_amqp_basic_cancel (state: POINTER; channel: NATURAL; consumer_tag: POINTER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_basic_cancel ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, *(amqp_bytes_t*)$consumer_tag);
			]"
		end

	c_amqp_basic_recover (state: POINTER; channel: NATURAL; requeue: INTEGER): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_basic_recover ((amqp_connection_state_t)$state, (amqp_channel_t)$channel, (amqp_boolean_t)$requeue);
			]"
		end

	c_amqp_tx_select (state: POINTER; channel: NATURAL): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_tx_select ((amqp_connection_state_t)$state, (amqp_channel_t)$channel);
			]"
		end

	c_amqp_tx_commit (state: POINTER; channel: NATURAL): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_tx_commit ((amqp_connection_state_t)$state, (amqp_channel_t)$channel);
			]"
		end

	c_amqp_tx_rollback (state: POINTER; channel: NATURAL): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_tx_rollback ((amqp_connection_state_t)$state, (amqp_channel_t)$channel);
			]"
		end

	c_amqp_confirm_select (state: POINTER; channel: NATURAL): POINTER
		external
			"C inline use <amqp.h>"
		alias
			"[
				return amqp_confirm_select ((amqp_connection_state_t)$state, (amqp_channel_t)$channel);
			]"
		end

feature -- Externals Address

end
